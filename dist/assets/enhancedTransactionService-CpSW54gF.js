var R=Object.defineProperty;var U=(p,e,t)=>e in p?R(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t;var u=(p,e,t)=>U(p,typeof e!="symbol"?e+"":e,t);import{P as w,m as N,a as A,T as v,b as F,s as M}from"./index-O-lUwgfL.js";var C={};const _={ethereum:{mainnet:"https://api.etherscan.io/api",apiKey:C.VITE_ETHERSCAN_API_KEY||"YourEtherscanAPIKey"},bitcoin:{mainnet:"https://blockstream.info/api",testnet:"https://blockstream.info/testnet/api"},polygon:{mainnet:"https://api.polygonscan.com/api",apiKey:C.VITE_POLYGONSCAN_API_KEY||"YourPolygonscanAPIKey"},bsc:{mainnet:"https://api.bscscan.com/api",apiKey:C.VITE_BSCSCAN_API_KEY||"YourBscscanAPIKey"}};class B{constructor(){u(this,"connectedWallets",new Map);u(this,"balanceCache",new Map);u(this,"transactionCache",new Map);u(this,"phase1FallbackActive",!1);u(this,"consecutiveFailures",0);u(this,"lastUpdate",null);u(this,"CACHE_DURATION",2*60*1e3);u(this,"TRANSACTION_CACHE_DURATION",5*60*1e3);u(this,"MAX_CONSECUTIVE_FAILURES",5);u(this,"RETRY_DELAY",2e3);this.initialize()}async initialize(){var e;try{console.log("üöÄ Initializing Enhanced Wallet Connectivity Service...");const t=((e=w)==null?void 0:e.enableRealWallets)||!1;console.log(`üìä Detected Phase: ${t?"Phase 2":"Phase 1"}`),t||(console.log("‚ö†Ô∏è Phase 2 wallet connectivity not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Wallet Connectivity Service initialized successfully"),console.log(`üìà Current mode: ${this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"}`)}catch(t){console.error("‚ùå Failed to initialize Wallet Connectivity Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 wallet fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,this.createMockWalletConnections(),console.log("‚úÖ Phase 1 wallet fallback mode activated successfully"),console.log(`üìä Created ${this.connectedWallets.size} mock wallet connections`)}catch(e){console.error("‚ùå Failed to activate Phase 1 wallet fallback:",e),this.connectedWallets.clear()}}createMockWalletConnections(){try{const e={address:"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9",network:"ethereum",provider:"mock",isConnected:!0,balances:this.createMockBalances("ethereum")},t={address:"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",network:"bitcoin",provider:"mock",isConnected:!0,balances:this.createMockBalances("bitcoin")};this.connectedWallets.set("mock_ethereum",e),this.connectedWallets.set("mock_bitcoin",t)}catch(e){console.error("‚ùå Error creating mock wallet connections:",e)}}createMockBalances(e){try{const t=[];return N.filter(n=>e==="ethereum"?["ethereum","usd-coin","tether"].includes(n.id):e==="bitcoin"?n.id==="bitcoin":!1).forEach(n=>{t.push({tokenId:n.id,symbol:n.symbol,balance:(Math.random()*10+.1).toFixed(4),balanceUSD:n.price*(Math.random()*10+.1),network:e,address:e==="ethereum"?"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9":"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",lastUpdated:new Date})}),t}catch(t){return console.error("‚ùå Error creating mock balances:",t),[]}}async connectWallet(e,t="ethereum",a="metamask"){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock wallet connection"),this.getMockWalletConnection(t);try{if(console.log(`üîó Connecting to wallet: ${e} on ${t}`),!this.isValidAddress(e,t))throw new Error(`Invalid ${t} address format`);const n=await this.fetchWalletBalances(e,t),o={address:e,network:t,provider:a,isConnected:!0,balances:n},s=`${e}_${t}`;return this.connectedWallets.set(s,o),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Successfully connected wallet with ${n.length} token balances`),o}catch(n){if(console.error("‚ùå Error connecting wallet:",n),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive wallet connection failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.getMockWalletConnection(t);const o=this.getMockWalletConnection(t);if(o)return console.log("üîÑ Returning mock wallet connection due to connection failure"),o;throw new Error(`Failed to connect wallet: ${n instanceof Error?n.message:"Unknown error"}`)}}getMockWalletConnection(e){try{const t=`mock_${e}`,a=this.connectedWallets.get(t);if(a)return a;const n={address:e==="ethereum"?"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9":"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",network:e,provider:"mock",isConnected:!0,balances:this.createMockBalances(e)};return this.connectedWallets.set(t,n),n}catch(t){return console.error("‚ùå Error creating mock wallet connection:",t),{address:"mock_address",network:e,provider:"mock",isConnected:!0,balances:[]}}}async fetchWalletBalances(e,t="ethereum"){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock balances"),this.createMockBalances(t);const a=`${e}_${t}`,n=this.balanceCache.get(a);if(n&&Date.now()-n.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached wallet balances"),n.balances;try{console.log(`üîÑ Fetching real balances for ${t} wallet: ${e}`);const o=[];switch(t){case"ethereum":const s=await this.fetchEthereumBalances(e);o.push(...s);break;case"bitcoin":const c=await this.fetchBitcoinBalance(e);c&&o.push(c);break;case"polygon":const i=await this.fetchPolygonBalances(e);o.push(...i);break;case"bsc":const r=await this.fetchBSCBalances(e);o.push(...r);break;default:throw new Error(`Unsupported network: ${t}`)}return this.balanceCache.set(a,{balances:o,timestamp:Date.now()}),console.log(`‚úÖ Fetched ${o.length} real balances for ${t} wallet`),o}catch(o){if(console.error(`‚ùå Error fetching ${t} balances:`,o),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive balance fetch failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockBalances(t);const s=this.balanceCache.get(a);return s?(console.log("üíæ Returning stale cached balances due to API error"),s.balances):(console.log("üîÑ No cached data available, returning mock balances"),this.createMockBalances(t))}}async fetchEthereumBalances(e){const t=[],a=_.ethereum;try{const o=await(await fetch(`${a.mainnet}?module=account&action=balance&address=${e}&tag=latest&apikey=${a.apiKey}`)).json();if(o.status==="1"){const i=(parseInt(o.result)/1e18).toString();t.push({tokenId:"ethereum",symbol:"ETH",balance:i,balanceUSD:0,network:"ethereum",address:e,lastUpdated:new Date})}const c=await(await fetch(`${a.mainnet}?module=account&action=tokentx&address=${e}&startblock=0&endblock=999999999&sort=desc&apikey=${a.apiKey}`)).json();if(c.status==="1"&&c.result){const i=new Map;c.result.forEach(r=>{i.has(r.contractAddress)||i.set(r.contractAddress,{symbol:r.tokenSymbol,decimals:parseInt(r.tokenDecimal)})});for(const[r,d]of i)try{const h=await(await fetch(`${a.mainnet}?module=account&action=tokenbalance&contractaddress=${r}&address=${e}&tag=latest&apikey=${a.apiKey}`)).json();if(h.status==="1"&&parseInt(h.result)>0){const l=(parseInt(h.result)/Math.pow(10,d.decimals)).toString();t.push({tokenId:this.getTokenIdFromSymbol(d.symbol),symbol:d.symbol,balance:l,balanceUSD:0,network:"ethereum",address:e,lastUpdated:new Date})}}catch(g){console.warn(`Error fetching balance for token ${d.symbol}:`,g)}}}catch(n){console.error("Error fetching Ethereum balances:",n)}return t}async fetchBitcoinBalance(e){try{const a=await(await fetch(`${_.bitcoin.mainnet}/address/${e}`)).json();if(a.chain_stats)return{tokenId:"bitcoin",symbol:"BTC",balance:(a.chain_stats.funded_txo_sum/1e8).toString(),balanceUSD:0,network:"bitcoin",address:e,lastUpdated:new Date}}catch(t){console.error("Error fetching Bitcoin balance:",t)}return null}async fetchPolygonBalances(e){return console.log("Polygon balance fetching not fully implemented yet"),[]}async fetchBSCBalances(e){return console.log("BSC balance fetching not fully implemented yet"),[]}isValidAddress(e,t){switch(t){case"ethereum":case"polygon":case"bsc":return/^0x[a-fA-F0-9]{40}$/.test(e);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(e)||/^bc1[a-z0-9]{39,59}$/.test(e);default:return!1}}getTokenIdFromSymbol(e){return{ETH:"ethereum",BTC:"bitcoin",USDC:"usd-coin",USDT:"tether",BNB:"binancecoin",MATIC:"matic-network",SOL:"solana",ADA:"cardano",XRP:"ripple"}[e.toUpperCase()]||e.toLowerCase()}getConnectedWallets(){return Array.from(this.connectedWallets.values())}disconnectWallet(e,t){const a=`${e}_${t}`;return this.connectedWallets.delete(a)}clearCaches(){this.balanceCache.clear(),this.transactionCache.clear()}getStatus(){return{connectedWalletsCount:this.connectedWallets.size,lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,balanceCacheSize:this.balanceCache.size,transactionCacheSize:this.transactionCache.size,supportedNetworks:["ethereum","bitcoin","polygon","bsc"]}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 wallet fallback mode...");try{return this.phase1FallbackActive=!1,this.consecutiveFailures=0,Array.from(this.connectedWallets.keys()).filter(t=>t.startsWith("mock_")).forEach(t=>this.connectedWallets.delete(t)),console.log("‚úÖ Successfully recovered from wallet fallback mode"),console.log("üí° Real wallet connections can now be attempted"),!0}catch(e){return console.error("‚ùå Error during wallet recovery attempt:",e),this.activatePhase1Fallback(),!1}}getTotalBalanceUSD(){try{let e=0;return this.connectedWallets.forEach(t=>{t.balances.forEach(a=>{e+=a.balanceUSD})}),e}catch(e){return console.error("‚ùå Error calculating total balance:",e),0}}getTokenBalanceAcrossWallets(e){try{const t=[];return this.connectedWallets.forEach(a=>{const n=a.balances.find(o=>o.tokenId===e);n&&t.push(n)}),t}catch(t){return console.error("‚ùå Error getting token balances across wallets:",t),[]}}destroy(){try{this.connectedWallets.clear(),this.clearCaches(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Wallet Connectivity Service destroyed")}catch(e){console.error("‚ùå Error during wallet service cleanup:",e)}}}const P=new B;var D={};const I={ethereum:{mainnet:"https://api.etherscan.io/api",apiKey:D.VITE_ETHERSCAN_API_KEY||"YourEtherscanAPIKey"},bitcoin:{mainnet:"https://blockstream.info/api"},polygon:{mainnet:"https://api.polygonscan.com/api",apiKey:D.VITE_POLYGONSCAN_API_KEY||"YourPolygonscanAPIKey"}};class W{constructor(){u(this,"transactionCache",new Map);u(this,"phase1FallbackActive",!1);u(this,"consecutiveFailures",0);u(this,"lastUpdate",null);u(this,"CACHE_DURATION",5*60*1e3);u(this,"MAX_CONSECUTIVE_FAILURES",5);u(this,"RETRY_DELAY",2e3);this.initialize()}async initialize(){var e;try{console.log("üöÄ Initializing Enhanced Real Transaction Service...");const t=((e=w)==null?void 0:e.enableRealTransactions)||!1;console.log(`üìä Detected Phase: ${t?"Phase 2":"Phase 1"}`),t||(console.log("‚ö†Ô∏è Phase 2 real transactions not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Real Transaction Service initialized successfully"),console.log(`üìà Current mode: ${this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"}`)}catch(t){console.error("‚ùå Failed to initialize Real Transaction Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 transaction fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("‚úÖ Phase 1 transaction fallback mode activated successfully"),console.log(`üìä Using ${A.length} mock transactions`)}catch(e){console.error("‚ùå Failed to activate Phase 1 transaction fallback:",e)}}async fetchTransactionHistory(e,t="ethereum",a=50){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock transactions"),this.createMockTransactionsForAddress(e,t,a);const n=`${e}_${t}_${a}`,o=this.transactionCache.get(n);if(o&&Date.now()-o.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached transaction history"),o.transactions;try{console.log(`üîÑ Fetching real transaction history for ${t} wallet: ${e}`);let s=[];switch(t){case"ethereum":s=await this.fetchEthereumTransactions(e,a);break;case"bitcoin":s=await this.fetchBitcoinTransactions(e,a);break;case"polygon":s=await this.fetchPolygonTransactions(e,a);break;default:return console.warn(`‚ö†Ô∏è Transaction fetching not implemented for network: ${t}`),this.createMockTransactionsForAddress(e,t,a)}return this.transactionCache.set(n,{transactions:s,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Fetched ${s.length} real transactions for ${t}`),s}catch(s){if(console.error(`‚ùå Error fetching transaction history for ${t}:`,s),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive transaction fetch failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockTransactionsForAddress(e,t,a);const c=this.transactionCache.get(n);return c?(console.log("üíæ Returning stale cached transactions due to API error"),c.transactions):(console.log("üîÑ No cached data available, returning mock transactions"),this.createMockTransactionsForAddress(e,t,a))}}createMockTransactionsForAddress(e,t,a){try{const n=[];return A.slice(0,a).forEach((s,c)=>{const i=Math.random()>.5;n.push({id:`${e}_${t}_${c}`,hash:`0x${Math.random().toString(16).substr(2,64)}`,from:i?`0x${Math.random().toString(16).substr(2,40)}`:e,to:i?e:`0x${Math.random().toString(16).substr(2,40)}`,value:(Math.random()*10+.01).toFixed(4),tokenSymbol:t==="bitcoin"?"BTC":"ETH",tokenId:t==="bitcoin"?"bitcoin":"ethereum",timestamp:new Date(Date.now()-Math.random()*30*24*60*60*1e3),blockNumber:Math.floor(Math.random()*1e6)+18e6,gasUsed:Math.floor(Math.random()*1e5)+21e3,gasPrice:Math.floor(Math.random()*50)+10,status:Math.random()>.1?"confirmed":"pending",network:t,type:i?"receive":"send"})}),n.sort((s,c)=>c.timestamp.getTime()-s.timestamp.getTime())}catch(n){return console.error("‚ùå Error creating mock transactions:",n),[]}}async fetchEthereumTransactions(e,t){const a=[],n=I.ethereum;try{const s=await(await fetch(`${n.mainnet}?module=account&action=txlist&address=${e}&startblock=0&endblock=99999999&page=1&offset=${t}&sort=desc&apikey=${n.apiKey}`)).json();if(s.status==="1"&&s.result)for(const r of s.result)a.push({id:r.hash,hash:r.hash,from:r.from,to:r.to,value:(parseInt(r.value)/1e18).toString(),tokenSymbol:"ETH",tokenId:"ethereum",timestamp:new Date(parseInt(r.timeStamp)*1e3),blockNumber:parseInt(r.blockNumber),gasUsed:r.gasUsed,gasPrice:r.gasPrice,status:r.txreceipt_status==="1"?"confirmed":"failed",network:"ethereum",type:r.from.toLowerCase()===e.toLowerCase()?"send":"receive"});const i=await(await fetch(`${n.mainnet}?module=account&action=tokentx&address=${e}&startblock=0&endblock=99999999&page=1&offset=${t}&sort=desc&apikey=${n.apiKey}`)).json();if(i.status==="1"&&i.result)for(const r of i.result){const d=parseInt(r.tokenDecimal),g=(parseInt(r.value)/Math.pow(10,d)).toString();a.push({id:`${r.hash}_${r.tokenSymbol}`,hash:r.hash,from:r.from,to:r.to,value:g,tokenSymbol:r.tokenSymbol,tokenId:this.getTokenIdFromSymbol(r.tokenSymbol),timestamp:new Date(parseInt(r.timeStamp)*1e3),blockNumber:parseInt(r.blockNumber),gasUsed:r.gasUsed,gasPrice:r.gasPrice,status:"confirmed",network:"ethereum",type:r.from.toLowerCase()===e.toLowerCase()?"send":"receive"})}}catch(o){console.error("Error fetching Ethereum transactions:",o)}return a.sort((o,s)=>s.timestamp.getTime()-o.timestamp.getTime()).slice(0,t)}async fetchBitcoinTransactions(e,t){const a=[];try{const o=await(await fetch(`${I.bitcoin.mainnet}/address/${e}/txs`)).json();if(Array.isArray(o))for(const s of o.slice(0,t)){const c=s.vout.some(g=>g.scriptpubkey_address===e),i=s.vin.some(g=>g.prevout&&g.prevout.scriptpubkey_address===e);let r="0",d="receive";c&&!i?(r=(s.vout.find(h=>h.scriptpubkey_address===e).value/1e8).toString(),d="receive"):i&&(r=(s.vin.filter(h=>h.prevout&&h.prevout.scriptpubkey_address===e).reduce((h,l)=>h+l.prevout.value,0)/1e8).toString(),d="send"),a.push({id:s.txid,hash:s.txid,from:d==="send"?e:"unknown",to:d==="receive"?e:"unknown",value:r,tokenSymbol:"BTC",tokenId:"bitcoin",timestamp:new Date(s.status.block_time*1e3),blockNumber:s.status.block_height,gasUsed:s.fee.toString(),gasPrice:"0",status:s.status.confirmed?"confirmed":"pending",network:"bitcoin",type:d})}}catch(n){console.error("Error fetching Bitcoin transactions:",n)}return a}async fetchPolygonTransactions(e,t){return console.log("Polygon transaction fetching not fully implemented yet"),[]}convertToAppTransactions(e){return e.map(t=>{const a={id:t.id,type:this.mapTransactionType(t.type),status:this.mapTransactionStatus(t.status),timestamp:t.timestamp.getTime(),hash:t.hash,account:t.from,from:t.from,to:t.to,fee:t.gasUsed,chain:t.network};return t.type==="send"?(a.fromAmount=t.value,a.amount=t.value):(t.type==="receive"&&(a.toAmount=t.value),a.amount=t.value),a})}mapTransactionType(e){switch(e){case"send":return v.SEND;case"receive":return v.RECEIVE;case"swap":return v.SWAP;case"stake":return v.STAKE;case"unstake":return v.UNSTAKE;default:return v.SEND}}mapTransactionStatus(e){switch(e){case"confirmed":return F.COMPLETED;case"pending":return F.PENDING;case"failed":return F.FAILED;default:return F.PENDING}}getTokenIdFromSymbol(e){return{ETH:"ethereum",BTC:"bitcoin",USDC:"usd-coin",USDT:"tether",BNB:"binancecoin",MATIC:"matic-network",SOL:"solana",ADA:"cardano",XRP:"ripple"}[e.toUpperCase()]||e.toLowerCase()}async getAllWalletTransactions(e=100){try{if(console.log("üîÑ Fetching transaction history for all connected wallets..."),this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e));const t=P.getConnectedWallets();if(t.length===0)return console.log("‚ö†Ô∏è No connected wallets found, returning mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e));const a=[];for(const o of t)try{const s=await this.fetchTransactionHistory(o.address,o.network,Math.ceil(e/t.length));a.push(...s)}catch(s){console.error(`‚ùå Error fetching transactions for wallet ${o.address}:`,s);const c=this.createMockTransactionsForAddress(o.address,o.network,Math.ceil(e/t.length));a.push(...c)}const n=a.sort((o,s)=>s.timestamp.getTime()-o.timestamp.getTime()).slice(0,e);return console.log(`‚úÖ Retrieved ${n.length} transactions from ${t.length} wallets`),this.convertToAppTransactions(n)}catch(t){return console.error("‚ùå Error in getAllWalletTransactions:",t),console.log("üîÑ Falling back to mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e))}}getStatus(){return{lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,transactionCacheSize:this.transactionCache.size,supportedNetworks:["ethereum","bitcoin","polygon"],cacheEntries:Array.from(this.transactionCache.keys())}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 transaction fallback mode...");try{this.phase1FallbackActive=!1,this.consecutiveFailures=0;const e=P.getConnectedWallets();if(e.length>0){const t=e[0];await this.fetchTransactionHistory(t.address,t.network,1)}return console.log("‚úÖ Successfully recovered from transaction fallback mode"),!0}catch(e){return console.error("‚ùå Error during transaction recovery attempt:",e),this.activatePhase1Fallback(),!1}}clearCache(){this.transactionCache.clear(),console.log("üßπ Transaction cache cleared")}destroy(){try{this.clearCache(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Real Transaction Service destroyed")}catch(e){console.error("‚ùå Error during transaction service cleanup:",e)}}}const O=new W,L=[{id:"defi",name:"DeFi",color:"#34C759",icon:"TrendingUp",description:"Decentralized Finance activities"},{id:"trading",name:"Trading",color:"#FF9500",icon:"BarChart3",description:"Buy, sell, and swap transactions"},{id:"transfer",name:"Transfer",color:"#007AFF",icon:"ArrowUpDown",description:"Send and receive transactions"},{id:"payment",name:"Payment",color:"#FF3B30",icon:"CreditCard",description:"Payment transactions"},{id:"staking",name:"Staking",color:"#5856D6",icon:"Coins",description:"Staking and rewards"},{id:"other",name:"Other",color:"#8E8E93",icon:"MoreHorizontal",description:"Other transaction types"}],z=[{id:"date",label:"Date",required:!0},{id:"type",label:"Type",required:!0},{id:"token",label:"Token",required:!0},{id:"amount",label:"Amount",required:!0},{id:"value_usd",label:"Value (USD)",required:!1},{id:"status",label:"Status",required:!0},{id:"category",label:"Category",required:!1},{id:"hash",label:"Transaction Hash",required:!1},{id:"wallet_id",label:"Wallet ID",required:!1},{id:"gas_fee",label:"Gas Fee",required:!1},{id:"from_address",label:"From Address",required:!1},{id:"to_address",label:"To Address",required:!1}];class V{constructor(){u(this,"phase1FallbackActive",!1);u(this,"consecutiveFailures",0);u(this,"lastUpdate",null);u(this,"analyticsCache",new Map);u(this,"MAX_CONSECUTIVE_FAILURES",5);u(this,"CACHE_DURATION",10*60*1e3);u(this,"RETRY_DELAY",2e3);this.initialize()}async initialize(){var e;try{console.log("üöÄ Initializing Enhanced Transaction Analytics Service...");const t=((e=w)==null?void 0:e.enableRealTransactions)||!1;console.log(`üìä Detected Phase: ${t?"Phase 2":"Phase 1"}`),t||(console.log("‚ö†Ô∏è Phase 2 enhanced analytics not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Transaction Analytics Service initialized successfully"),console.log(`üìà Current mode: ${this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"}`)}catch(t){console.error("‚ùå Failed to initialize Enhanced Transaction Analytics Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 enhanced analytics fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("‚úÖ Phase 1 enhanced analytics fallback mode activated successfully"),console.log(`üìä Using mock analytics based on ${A.length} mock transactions`)}catch(e){console.error("‚ùå Failed to activate Phase 1 enhanced analytics fallback:",e)}}createMockAnalytics(e,t={}){try{const a=A.slice(0,50);let n=0;const o={},s={},c={};a.forEach(h=>{const m=parseFloat(h.amount||"0")*(Math.random()*100+50);n+=m;const f=this.categorizeTransaction(h);o[f]=(o[f]||0)+m;const b=Math.floor(Math.random()*6),k=new Date;k.setMonth(k.getMonth()-b);const T=k.toISOString().slice(0,7);s[T]=(s[T]||0)+m;const y=h.fromToken||"ethereum";c[y]||(c[y]={volume:0,count:0}),c[y].volume+=m,c[y].count+=1});const i=a.length,r=i>0?n/i:0,d=Object.entries(s).map(([h,l])=>({month:h,volume:l})).sort((h,l)=>h.month.localeCompare(l.month)),g=Object.entries(c).map(([h,l])=>({tokenId:h,...l})).sort((h,l)=>l.volume-h.volume).slice(0,10);return{totalTransactions:i,totalVolume:n,averageAmount:r,categoryBreakdown:o,monthlyVolume:d,topTokens:g}}catch(a){return console.error("‚ùå Error creating mock analytics:",a),{totalTransactions:0,totalVolume:0,averageAmount:0,categoryBreakdown:{},monthlyVolume:[],topTokens:[]}}}async getFilteredTransactions(e,t={},a={page:1,limit:20}){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock filtered transactions"),this.createMockFilteredTransactions(e,t,a);const n=`filtered_${e}_${JSON.stringify(t)}_${JSON.stringify(a)}`,o=this.analyticsCache.get(n);if(o&&Date.now()-o.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached filtered transactions"),o.data;try{console.log("üîÑ Fetching real filtered transactions...");const s=await O.getAllWalletTransactions(a.limit);if(s&&s.length>0){const i={transactions:s.slice(0,a.limit),total:s.length};return this.analyticsCache.set(n,{data:i,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Retrieved ${i.transactions.length} real filtered transactions`),i}const c=await $(e,t,a);return this.analyticsCache.set(n,{data:c,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Retrieved ${c.transactions.length} filtered transactions from Supabase`),c}catch(s){if(console.error("‚ùå Error fetching filtered transactions:",s),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive analytics failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockFilteredTransactions(e,t,a);const c=this.analyticsCache.get(n);return c?(console.log("üíæ Returning stale cached filtered transactions due to error"),c.data):(console.log("üîÑ No cached data available, returning mock filtered transactions"),this.createMockFilteredTransactions(e,t,a))}}createMockFilteredTransactions(e,t={},a={page:1,limit:20}){try{let n=[...A];t.transactionType&&(n=n.filter(i=>i.type===t.transactionType)),t.status&&(n=n.filter(i=>i.status===t.status)),t.tokenFilter&&(n=n.filter(i=>{var r,d;return((r=i.fromToken)==null?void 0:r.toLowerCase().includes(t.tokenFilter.toLowerCase()))||((d=i.toToken)==null?void 0:d.toLowerCase().includes(t.tokenFilter.toLowerCase()))}));const o=(a.page-1)*a.limit,s=o+a.limit;return{transactions:n.slice(o,s),total:n.length}}catch(n){return console.error("‚ùå Error creating mock filtered transactions:",n),{transactions:[],total:0}}}async getTransactionAnalytics(e,t={}){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock analytics"),this.createMockAnalytics(e,t);const a=`analytics_${e}_${JSON.stringify(t)}`,n=this.analyticsCache.get(a);if(n&&Date.now()-n.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached analytics"),n.data;try{console.log("üîÑ Fetching real transaction analytics...");const o=await K(e,t);return this.analyticsCache.set(a,{data:o,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("‚úÖ Retrieved real transaction analytics"),o}catch(o){if(console.error("‚ùå Error fetching transaction analytics:",o),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive analytics failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockAnalytics(e,t);const s=this.analyticsCache.get(a);return s?(console.log("üíæ Returning stale cached analytics due to error"),s.data):(console.log("üîÑ No cached data available, returning mock analytics"),this.createMockAnalytics(e,t))}}categorizeTransaction(e){var a,n;switch(((a=e.type)==null?void 0:a.toLowerCase())||((n=e.transaction_type)==null?void 0:n.toLowerCase())){case"stake":case"unstake":case"claim_rewards":return"staking";case"swap":case"buy":case"sell":return"trading";case"send":case"receive":return"transfer";case"payment":return"payment";case"liquidity_add":case"liquidity_remove":case"yield_farm":return"defi";default:return"other"}}getStatus(){return{lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,analyticsCacheSize:this.analyticsCache.size,supportedFeatures:["filtering","analytics","categorization","export"],cacheEntries:Array.from(this.analyticsCache.keys())}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 enhanced analytics fallback mode...");try{return this.phase1FallbackActive=!1,this.consecutiveFailures=0,await this.getTransactionAnalytics("test_user",{}),console.log("‚úÖ Successfully recovered from enhanced analytics fallback mode"),!0}catch(e){return console.error("‚ùå Error during enhanced analytics recovery attempt:",e),this.activatePhase1Fallback(),!1}}clearCache(){this.analyticsCache.clear(),console.log("üßπ Enhanced analytics cache cleared")}destroy(){try{this.clearCache(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Enhanced Transaction Analytics Service destroyed")}catch(e){console.error("‚ùå Error during enhanced analytics service cleanup:",e)}}}new V;const $=async(p,e={},t={page:1,limit:20})=>{try{let a=M.from("transactions").select(`
        *,
        tokens:from_token_id (
          id,
          symbol,
          name,
          logo,
          decimals,
          price
        )
      `,{count:"exact"}).eq("user_id",p);e.walletId&&(a=a.eq("wallet_id",e.walletId)),e.transactionType&&(a=a.eq("transaction_type",e.transactionType)),e.status&&(a=a.eq("status",e.status)),e.tokenId&&(a=a.eq("from_token_id",e.tokenId)),e.dateRange?a=a.gte("timestamp",e.dateRange.from.toISOString()).lte("timestamp",e.dateRange.to.toISOString()):(e.dateFrom&&(a=a.gte("timestamp",e.dateFrom)),e.dateTo&&(a=a.lte("timestamp",e.dateTo))),e.tokenFilter&&(a=a.or(`tokens.symbol.ilike.%${e.tokenFilter}%,tokens.name.ilike.%${e.tokenFilter}%`)),e.amountMin&&(a=a.gte("from_amount",e.amountMin.toString())),e.amountMax&&(a=a.lte("from_amount",e.amountMax.toString())),e.category&&(a=a.eq("category",e.category));const n=(t.page-1)*t.limit;a=a.order("timestamp",{ascending:!1}).range(n,n+t.limit-1);const{data:o,error:s,count:c}=await a;return s?(console.error("Error fetching filtered transactions:",s),{transactions:[],total:0}):{transactions:o||[],total:c||0}}catch(a){return console.error("Error in getFilteredTransactions:",a),{transactions:[],total:0}}},K=async(p,e={})=>{try{let t=M.from("transactions").select(`
        *,
        tokens:from_token_id (
          id,
          symbol,
          name,
          price
        )
      `).eq("user_id",p);e.walletId&&(t=t.eq("wallet_id",e.walletId)),e.dateFrom&&(t=t.gte("timestamp",e.dateFrom)),e.dateTo&&(t=t.lte("timestamp",e.dateTo));const{data:a,error:n}=await t;if(n||!a)return console.error("Error fetching transaction analytics:",n),{totalTransactions:0,totalVolume:0,averageAmount:0,categoryBreakdown:{},monthlyVolume:[],topTokens:[]};const o=a.length;let s=0;const c={},i={},r={};a.forEach(l=>{var E,S;const m=parseFloat(l.from_amount||"0"),f=((E=l.tokens)==null?void 0:E.price)||0,b=m*f;s+=b;const k=l.category||"other";c[k]=(c[k]||0)+b;const T=new Date(l.timestamp).toISOString().slice(0,7);i[T]=(i[T]||0)+b;const y=l.from_token_id;y&&(r[y]||(r[y]={volume:0,count:0,symbol:((S=l.tokens)==null?void 0:S.symbol)||"Unknown"}),r[y].volume+=b,r[y].count+=1)});const d=o>0?s/o:0,g=Object.entries(i).map(([l,m])=>({month:l,volume:m})).sort((l,m)=>l.month.localeCompare(m.month)),h=Object.entries(r).map(([l,m])=>({tokenId:l,...m})).sort((l,m)=>m.volume-l.volume).slice(0,10);return{totalTransactions:o,totalVolume:s,averageAmount:d,categoryBreakdown:c,monthlyVolume:g,topTokens:h}}catch(t){return console.error("Error in getTransactionAnalytics:",t),{totalTransactions:0,totalVolume:0,averageAmount:0,categoryBreakdown:{},monthlyVolume:[],topTokens:[]}}},q=p=>{var t;switch((t=p.transaction_type)==null?void 0:t.toLowerCase()){case"stake":case"unstake":case"claim_rewards":return"staking";case"swap":case"buy":case"sell":return"trading";case"send":case"receive":return"transfer";case"payment":return"payment";case"liquidity_add":case"liquidity_remove":case"yield_farm":return"defi";default:return"other"}},j=async(p,e)=>{try{let t={};if(e.dateRange==="custom"&&e.customDateRange)t.dateRange=e.customDateRange;else{const c=new Date,i=new Date;switch(e.dateRange){case"last30days":i.setDate(c.getDate()-30);break;case"last90days":i.setDate(c.getDate()-90);break;case"alltime":i.setFullYear(2020);break}t.dateRange={from:i,to:c}}const{transactions:a}=await $(p,t,{page:1,limit:1e4}),n=e.includeFields.map(c=>{const i=z.find(r=>r.id===c);return(i==null?void 0:i.label)||c}),o=a.map(c=>e.includeFields.map(i=>{var r,d;switch(i){case"date":return new Date(c.timestamp).toLocaleDateString();case"type":return c.transaction_type||"Unknown";case"token":return((r=c.tokens)==null?void 0:r.symbol)||"Unknown";case"amount":return c.from_amount||"0";case"value_usd":const g=parseFloat(c.from_amount||"0"),h=((d=c.tokens)==null?void 0:d.price)||0;return(g*h).toFixed(2);case"status":return c.status||"Unknown";case"category":const l=q(c),m=L.find(f=>f.id===l);return(m==null?void 0:m.name)||"Other";case"hash":return c.hash||"";case"wallet_id":return c.wallet_id||"";case"gas_fee":return c.gas_fee||"0";case"from_address":return c.from_address||"";case"to_address":return c.to_address||"";default:return""}}));return[n,...o].map(c=>c.map(i=>`"${i}"`).join(",")).join(`
`)}catch(t){throw console.error("Error exporting transactions to CSV:",t),new Error("Failed to export transactions")}};export{z as EXPORT_FIELDS,L as TRANSACTION_CATEGORIES,q as categorizeTransaction,j as exportTransactionsToCSV,$ as getFilteredTransactions,K as getTransactionAnalytics};
