var y=Object.defineProperty;var A=(m,e,t)=>e in m?y(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t;var h=(m,e,t)=>A(m,typeof e!="symbol"?e+"":e,t);import{P as F,m as g,T as d,a as f}from"./index-CzdJEBKI.js";import{walletConnectivityService as k}from"./walletConnectivityService-YzB1ZbNa.js";var v={};const T={ethereum:{mainnet:"https://api.etherscan.io/api",apiKey:v.VITE_ETHERSCAN_API_KEY||"YourEtherscanAPIKey"},bitcoin:{mainnet:"https://blockstream.info/api"},polygon:{mainnet:"https://api.polygonscan.com/api",apiKey:v.VITE_POLYGONSCAN_API_KEY||"YourPolygonscanAPIKey"}};class E{constructor(){h(this,"transactionCache",new Map);h(this,"phase1FallbackActive",!1);h(this,"consecutiveFailures",0);h(this,"lastUpdate",null);h(this,"CACHE_DURATION",5*60*1e3);h(this,"MAX_CONSECUTIVE_FAILURES",5);h(this,"RETRY_DELAY",2e3);this.initialize()}async initialize(){var e;try{console.log("🚀 Initializing Enhanced Real Transaction Service...");const t=((e=F)==null?void 0:e.enableRealTransactions)||!1;console.log(`📊 Detected Phase: ${t?"Phase 2":"Phase 1"}`),t||(console.log("⚠️ Phase 2 real transactions not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("✅ Enhanced Real Transaction Service initialized successfully"),console.log(`📈 Current mode: ${this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"}`)}catch(t){console.error("❌ Failed to initialize Real Transaction Service:",t),console.log("🔄 Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("🔄 Activating Phase 1 transaction fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("✅ Phase 1 transaction fallback mode activated successfully"),console.log(`📊 Using ${g.length} mock transactions`)}catch(e){console.error("❌ Failed to activate Phase 1 transaction fallback:",e)}}async fetchTransactionHistory(e,t="ethereum",o=50){if(this.phase1FallbackActive)return console.log("📊 Phase 1 fallback mode active, returning mock transactions"),this.createMockTransactionsForAddress(e,t,o);const r=`${e}_${t}_${o}`,n=this.transactionCache.get(r);if(n&&Date.now()-n.timestamp<this.CACHE_DURATION)return console.log("💾 Returning cached transaction history"),n.transactions;try{console.log(`🔄 Fetching real transaction history for ${t} wallet: ${e}`);let a=[];switch(t){case"ethereum":a=await this.fetchEthereumTransactions(e,o);break;case"bitcoin":a=await this.fetchBitcoinTransactions(e,o);break;case"polygon":a=await this.fetchPolygonTransactions(e,o);break;default:return console.warn(`⚠️ Transaction fetching not implemented for network: ${t}`),this.createMockTransactionsForAddress(e,t,o)}return this.transactionCache.set(r,{transactions:a,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`✅ Fetched ${a.length} real transactions for ${t}`),a}catch(a){if(console.error(`❌ Error fetching transaction history for ${t}:`,a),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`⚠️ ${this.consecutiveFailures} consecutive transaction fetch failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockTransactionsForAddress(e,t,o);const c=this.transactionCache.get(r);return c?(console.log("💾 Returning stale cached transactions due to API error"),c.transactions):(console.log("🔄 No cached data available, returning mock transactions"),this.createMockTransactionsForAddress(e,t,o))}}createMockTransactionsForAddress(e,t,o){try{const r=[];return g.slice(0,o).forEach((a,c)=>{const i=Math.random()>.5;r.push({id:`${e}_${t}_${c}`,hash:`0x${Math.random().toString(16).substr(2,64)}`,from:i?`0x${Math.random().toString(16).substr(2,40)}`:e,to:i?e:`0x${Math.random().toString(16).substr(2,40)}`,value:(Math.random()*10+.01).toFixed(4),tokenSymbol:t==="bitcoin"?"BTC":"ETH",tokenId:t==="bitcoin"?"bitcoin":"ethereum",timestamp:new Date(Date.now()-Math.random()*30*24*60*60*1e3),blockNumber:Math.floor(Math.random()*1e6)+18e6,gasUsed:Math.floor(Math.random()*1e5)+21e3,gasPrice:Math.floor(Math.random()*50)+10,status:Math.random()>.1?"confirmed":"pending",network:t,type:i?"receive":"send"})}),r.sort((a,c)=>c.timestamp.getTime()-a.timestamp.getTime())}catch(r){return console.error("❌ Error creating mock transactions:",r),[]}}async fetchEthereumTransactions(e,t){const o=[],r=T.ethereum;try{const a=await(await fetch(`${r.mainnet}?module=account&action=txlist&address=${e}&startblock=0&endblock=99999999&page=1&offset=${t}&sort=desc&apikey=${r.apiKey}`)).json();if(a.status==="1"&&a.result)for(const s of a.result)o.push({id:s.hash,hash:s.hash,from:s.from,to:s.to,value:(parseInt(s.value)/1e18).toString(),tokenSymbol:"ETH",tokenId:"ethereum",timestamp:new Date(parseInt(s.timeStamp)*1e3),blockNumber:parseInt(s.blockNumber),gasUsed:s.gasUsed,gasPrice:s.gasPrice,status:s.txreceipt_status==="1"?"confirmed":"failed",network:"ethereum",type:s.from.toLowerCase()===e.toLowerCase()?"send":"receive"});const i=await(await fetch(`${r.mainnet}?module=account&action=tokentx&address=${e}&startblock=0&endblock=99999999&page=1&offset=${t}&sort=desc&apikey=${r.apiKey}`)).json();if(i.status==="1"&&i.result)for(const s of i.result){const u=parseInt(s.tokenDecimal),l=(parseInt(s.value)/Math.pow(10,u)).toString();o.push({id:`${s.hash}_${s.tokenSymbol}`,hash:s.hash,from:s.from,to:s.to,value:l,tokenSymbol:s.tokenSymbol,tokenId:this.getTokenIdFromSymbol(s.tokenSymbol),timestamp:new Date(parseInt(s.timeStamp)*1e3),blockNumber:parseInt(s.blockNumber),gasUsed:s.gasUsed,gasPrice:s.gasPrice,status:"confirmed",network:"ethereum",type:s.from.toLowerCase()===e.toLowerCase()?"send":"receive"})}}catch(n){console.error("Error fetching Ethereum transactions:",n)}return o.sort((n,a)=>a.timestamp.getTime()-n.timestamp.getTime()).slice(0,t)}async fetchBitcoinTransactions(e,t){const o=[];try{const n=await(await fetch(`${T.bitcoin.mainnet}/address/${e}/txs`)).json();if(Array.isArray(n))for(const a of n.slice(0,t)){const c=a.vout.some(l=>l.scriptpubkey_address===e),i=a.vin.some(l=>l.prevout&&l.prevout.scriptpubkey_address===e);let s="0",u="receive";c&&!i?(s=(a.vout.find(p=>p.scriptpubkey_address===e).value/1e8).toString(),u="receive"):i&&(s=(a.vin.filter(p=>p.prevout&&p.prevout.scriptpubkey_address===e).reduce((p,b)=>p+b.prevout.value,0)/1e8).toString(),u="send"),o.push({id:a.txid,hash:a.txid,from:u==="send"?e:"unknown",to:u==="receive"?e:"unknown",value:s,tokenSymbol:"BTC",tokenId:"bitcoin",timestamp:new Date(a.status.block_time*1e3),blockNumber:a.status.block_height,gasUsed:a.fee.toString(),gasPrice:"0",status:a.status.confirmed?"confirmed":"pending",network:"bitcoin",type:u})}}catch(r){console.error("Error fetching Bitcoin transactions:",r)}return o}async fetchPolygonTransactions(e,t){return console.log("Polygon transaction fetching not fully implemented yet"),[]}convertToAppTransactions(e){return e.map(t=>{const o={id:t.id,type:this.mapTransactionType(t.type),status:this.mapTransactionStatus(t.status),timestamp:t.timestamp.getTime(),hash:t.hash,account:t.from,from:t.from,to:t.to,fee:t.gasUsed,chain:t.network};return t.type==="send"?(o.fromAmount=t.value,o.amount=t.value):(t.type==="receive"&&(o.toAmount=t.value),o.amount=t.value),o})}mapTransactionType(e){switch(e){case"send":return d.SEND;case"receive":return d.RECEIVE;case"swap":return d.SWAP;case"stake":return d.STAKE;case"unstake":return d.UNSTAKE;default:return d.SEND}}mapTransactionStatus(e){switch(e){case"confirmed":return f.COMPLETED;case"pending":return f.PENDING;case"failed":return f.FAILED;default:return f.PENDING}}getTokenIdFromSymbol(e){return{ETH:"ethereum",BTC:"bitcoin",USDC:"usd-coin",USDT:"tether",BNB:"binancecoin",MATIC:"matic-network",SOL:"solana",ADA:"cardano",XRP:"ripple"}[e.toUpperCase()]||e.toLowerCase()}async getAllWalletTransactions(e=100){try{if(console.log("🔄 Fetching transaction history for all connected wallets..."),this.phase1FallbackActive)return console.log("📊 Phase 1 fallback mode active, returning mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e));const t=k.getConnectedWallets();if(t.length===0)return console.log("⚠️ No connected wallets found, returning mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e));const o=[];for(const n of t)try{const a=await this.fetchTransactionHistory(n.address,n.network,Math.ceil(e/t.length));o.push(...a)}catch(a){console.error(`❌ Error fetching transactions for wallet ${n.address}:`,a);const c=this.createMockTransactionsForAddress(n.address,n.network,Math.ceil(e/t.length));o.push(...c)}const r=o.sort((n,a)=>a.timestamp.getTime()-n.timestamp.getTime()).slice(0,e);return console.log(`✅ Retrieved ${r.length} transactions from ${t.length} wallets`),this.convertToAppTransactions(r)}catch(t){return console.error("❌ Error in getAllWalletTransactions:",t),console.log("🔄 Falling back to mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e))}}getStatus(){return{lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,transactionCacheSize:this.transactionCache.size,supportedNetworks:["ethereum","bitcoin","polygon"],cacheEntries:Array.from(this.transactionCache.keys())}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("📊 Not in fallback mode, no recovery needed"),!0;console.log("🔄 Attempting recovery from Phase 1 transaction fallback mode...");try{this.phase1FallbackActive=!1,this.consecutiveFailures=0;const e=k.getConnectedWallets();if(e.length>0){const t=e[0];await this.fetchTransactionHistory(t.address,t.network,1)}return console.log("✅ Successfully recovered from transaction fallback mode"),!0}catch(e){return console.error("❌ Error during transaction recovery attempt:",e),this.activatePhase1Fallback(),!1}}clearCache(){this.transactionCache.clear(),console.log("🧹 Transaction cache cleared")}destroy(){try{this.clearCache(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("🧹 Real Transaction Service destroyed")}catch(e){console.error("❌ Error during transaction service cleanup:",e)}}}const C=new E;export{C as default,C as realTransactionService};
