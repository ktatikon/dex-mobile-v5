var k=Object.defineProperty;var g=(i,e,t)=>e in i?k(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>g(i,typeof e!="symbol"?e+"":e,t);import{P as y,b as v}from"./index-C9SSiDPj.js";var d={};const f={ethereum:{mainnet:"https://api.etherscan.io/api",apiKey:d.VITE_ETHERSCAN_API_KEY||"YourEtherscanAPIKey"},bitcoin:{mainnet:"https://blockstream.info/api",testnet:"https://blockstream.info/testnet/api"},polygon:{mainnet:"https://api.polygonscan.com/api",apiKey:d.VITE_POLYGONSCAN_API_KEY||"YourPolygonscanAPIKey"},bsc:{mainnet:"https://api.bscscan.com/api",apiKey:d.VITE_BSCSCAN_API_KEY||"YourBscscanAPIKey"}};class C{constructor(){o(this,"connectedWallets",new Map);o(this,"balanceCache",new Map);o(this,"transactionCache",new Map);o(this,"phase1FallbackActive",!1);o(this,"consecutiveFailures",0);o(this,"lastUpdate",null);o(this,"CACHE_DURATION",2*60*1e3);o(this,"TRANSACTION_CACHE_DURATION",5*60*1e3);o(this,"MAX_CONSECUTIVE_FAILURES",5);o(this,"RETRY_DELAY",2e3);this.initialize()}async initialize(){var e;try{console.log("üöÄ Initializing Enhanced Wallet Connectivity Service...");const t=((e=y)==null?void 0:e.enableRealWallets)||!1;console.log(`üìä Detected Phase: ${t?"Phase 2":"Phase 1"}`),t||(console.log("‚ö†Ô∏è Phase 2 wallet connectivity not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Wallet Connectivity Service initialized successfully"),console.log(`üìà Current mode: ${this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"}`)}catch(t){console.error("‚ùå Failed to initialize Wallet Connectivity Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 wallet fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,this.createMockWalletConnections(),console.log("‚úÖ Phase 1 wallet fallback mode activated successfully"),console.log(`üìä Created ${this.connectedWallets.size} mock wallet connections`)}catch(e){console.error("‚ùå Failed to activate Phase 1 wallet fallback:",e),this.connectedWallets.clear()}}createMockWalletConnections(){try{const e={address:"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9",network:"ethereum",provider:"mock",isConnected:!0,balances:this.createMockBalances("ethereum")},t={address:"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",network:"bitcoin",provider:"mock",isConnected:!0,balances:this.createMockBalances("bitcoin")};this.connectedWallets.set("mock_ethereum",e),this.connectedWallets.set("mock_bitcoin",t)}catch(e){console.error("‚ùå Error creating mock wallet connections:",e)}}createMockBalances(e){try{const t=[];return v.filter(a=>e==="ethereum"?["ethereum","usd-coin","tether"].includes(a.id):e==="bitcoin"?a.id==="bitcoin":!1).forEach(a=>{t.push({tokenId:a.id,symbol:a.symbol,balance:(Math.random()*10+.1).toFixed(4),balanceUSD:a.price*(Math.random()*10+.1),network:e,address:e==="ethereum"?"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9":"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",lastUpdated:new Date})}),t}catch(t){return console.error("‚ùå Error creating mock balances:",t),[]}}async connectWallet(e,t="ethereum",c="metamask"){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock wallet connection"),this.getMockWalletConnection(t);try{if(console.log(`üîó Connecting to wallet: ${e} on ${t}`),!this.isValidAddress(e,t))throw new Error(`Invalid ${t} address format`);const a=await this.fetchWalletBalances(e,t),n={address:e,network:t,provider:c,isConnected:!0,balances:a},l=`${e}_${t}`;return this.connectedWallets.set(l,n),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Successfully connected wallet with ${a.length} token balances`),n}catch(a){if(console.error("‚ùå Error connecting wallet:",a),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive wallet connection failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.getMockWalletConnection(t);const n=this.getMockWalletConnection(t);if(n)return console.log("üîÑ Returning mock wallet connection due to connection failure"),n;throw new Error(`Failed to connect wallet: ${a instanceof Error?a.message:"Unknown error"}`)}}getMockWalletConnection(e){try{const t=`mock_${e}`,c=this.connectedWallets.get(t);if(c)return c;const a={address:e==="ethereum"?"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9":"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",network:e,provider:"mock",isConnected:!0,balances:this.createMockBalances(e)};return this.connectedWallets.set(t,a),a}catch(t){return console.error("‚ùå Error creating mock wallet connection:",t),{address:"mock_address",network:e,provider:"mock",isConnected:!0,balances:[]}}}async fetchWalletBalances(e,t="ethereum"){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock balances"),this.createMockBalances(t);const c=`${e}_${t}`,a=this.balanceCache.get(c);if(a&&Date.now()-a.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached wallet balances"),a.balances;try{console.log(`üîÑ Fetching real balances for ${t} wallet: ${e}`);const n=[];switch(t){case"ethereum":const l=await this.fetchEthereumBalances(e);n.push(...l);break;case"bitcoin":const h=await this.fetchBitcoinBalance(e);h&&n.push(h);break;case"polygon":const r=await this.fetchPolygonBalances(e);n.push(...r);break;case"bsc":const s=await this.fetchBSCBalances(e);n.push(...s);break;default:throw new Error(`Unsupported network: ${t}`)}return this.balanceCache.set(c,{balances:n,timestamp:Date.now()}),console.log(`‚úÖ Fetched ${n.length} real balances for ${t} wallet`),n}catch(n){if(console.error(`‚ùå Error fetching ${t} balances:`,n),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive balance fetch failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockBalances(t);const l=this.balanceCache.get(c);return l?(console.log("üíæ Returning stale cached balances due to API error"),l.balances):(console.log("üîÑ No cached data available, returning mock balances"),this.createMockBalances(t))}}async fetchEthereumBalances(e){const t=[],c=f.ethereum;try{const n=await(await fetch(`${c.mainnet}?module=account&action=balance&address=${e}&tag=latest&apikey=${c.apiKey}`)).json();if(n.status==="1"){const r=(parseInt(n.result)/1e18).toString();t.push({tokenId:"ethereum",symbol:"ETH",balance:r,balanceUSD:0,network:"ethereum",address:e,lastUpdated:new Date})}const h=await(await fetch(`${c.mainnet}?module=account&action=tokentx&address=${e}&startblock=0&endblock=999999999&sort=desc&apikey=${c.apiKey}`)).json();if(h.status==="1"&&h.result){const r=new Map;h.result.forEach(s=>{r.has(s.contractAddress)||r.set(s.contractAddress,{symbol:s.tokenSymbol,decimals:parseInt(s.tokenDecimal)})});for(const[s,u]of r)try{const b=await(await fetch(`${c.mainnet}?module=account&action=tokenbalance&contractaddress=${s}&address=${e}&tag=latest&apikey=${c.apiKey}`)).json();if(b.status==="1"&&parseInt(b.result)>0){const p=(parseInt(b.result)/Math.pow(10,u.decimals)).toString();t.push({tokenId:this.getTokenIdFromSymbol(u.symbol),symbol:u.symbol,balance:p,balanceUSD:0,network:"ethereum",address:e,lastUpdated:new Date})}}catch(m){console.warn(`Error fetching balance for token ${u.symbol}:`,m)}}}catch(a){console.error("Error fetching Ethereum balances:",a)}return t}async fetchBitcoinBalance(e){try{const c=await(await fetch(`${f.bitcoin.mainnet}/address/${e}`)).json();if(c.chain_stats)return{tokenId:"bitcoin",symbol:"BTC",balance:(c.chain_stats.funded_txo_sum/1e8).toString(),balanceUSD:0,network:"bitcoin",address:e,lastUpdated:new Date}}catch(t){console.error("Error fetching Bitcoin balance:",t)}return null}async fetchPolygonBalances(e){return console.log("Polygon balance fetching not fully implemented yet"),[]}async fetchBSCBalances(e){return console.log("BSC balance fetching not fully implemented yet"),[]}isValidAddress(e,t){switch(t){case"ethereum":case"polygon":case"bsc":return/^0x[a-fA-F0-9]{40}$/.test(e);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(e)||/^bc1[a-z0-9]{39,59}$/.test(e);default:return!1}}getTokenIdFromSymbol(e){return{ETH:"ethereum",BTC:"bitcoin",USDC:"usd-coin",USDT:"tether",BNB:"binancecoin",MATIC:"matic-network",SOL:"solana",ADA:"cardano",XRP:"ripple"}[e.toUpperCase()]||e.toLowerCase()}getConnectedWallets(){return Array.from(this.connectedWallets.values())}disconnectWallet(e,t){const c=`${e}_${t}`;return this.connectedWallets.delete(c)}clearCaches(){this.balanceCache.clear(),this.transactionCache.clear()}getStatus(){return{connectedWalletsCount:this.connectedWallets.size,lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,balanceCacheSize:this.balanceCache.size,transactionCacheSize:this.transactionCache.size,supportedNetworks:["ethereum","bitcoin","polygon","bsc"]}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 wallet fallback mode...");try{return this.phase1FallbackActive=!1,this.consecutiveFailures=0,Array.from(this.connectedWallets.keys()).filter(t=>t.startsWith("mock_")).forEach(t=>this.connectedWallets.delete(t)),console.log("‚úÖ Successfully recovered from wallet fallback mode"),console.log("üí° Real wallet connections can now be attempted"),!0}catch(e){return console.error("‚ùå Error during wallet recovery attempt:",e),this.activatePhase1Fallback(),!1}}getTotalBalanceUSD(){try{let e=0;return this.connectedWallets.forEach(t=>{t.balances.forEach(c=>{e+=c.balanceUSD})}),e}catch(e){return console.error("‚ùå Error calculating total balance:",e),0}}getTokenBalanceAcrossWallets(e){try{const t=[];return this.connectedWallets.forEach(c=>{const a=c.balances.find(n=>n.tokenId===e);a&&t.push(a)}),t}catch(t){return console.error("‚ùå Error getting token balances across wallets:",t),[]}}destroy(){try{this.connectedWallets.clear(),this.clearCaches(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Wallet Connectivity Service destroyed")}catch(e){console.error("‚ùå Error during wallet service cleanup:",e)}}}const w=new C;export{w as default,w as walletConnectivityService};
